如果不是面专门的算法类岗位，面试最高频问题是这几类：大数据、数组、树、查找和排序，其中查找和排序最经常考的就是快排和二分查找了，一定要任何时候都可以手写出来。  
如果时间实在不够，就把上面提到的内容重点过一下，临阵磨枪，不亮也光。  
刷题除了答案本身有意义之外更重要的是解决的过程，把如何思考的过程记录下来，这样就可以总结出一些规律，有了思路以后写代码还是比较简单的，当然不排除某些比较难或者过程比较复杂的题目，这个时候还应当记录一下代码上的一些小彩蛋。  
这里的题目主要来源是 [剑指 offer](https://book.douban.com/subject/6966465/)，[程序员代码面试指南](https://book.douban.com/subject/26638586/)，[leetcode](https://leetcode.com)。
## 查找与排序
**输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素**  
看到递增想到使用二分查找，可以依次分析中间的数值和首末位置数值的大小关系然后做出判断，但是注意可能会出现中间位置的数值等于首末位置的数值，这种情况只能使用顺序查找。

**输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变**  
由于要保证输入的相对位置不变，所以可以考虑使用类似于插入排序的方法。



## 大数据
**从一个大文件中找出出现次数最多的 IP，假设只提供 1G 的内存空间。**  
1. IP 地址最多有 2^32=4G 种取值情况，所以不能完全加载到内存中处理；
2. 可以考虑采用“分而治之”的思想，按照 IP 地址的 Hash(IP)%1024 值，把海量IP日志分别存储到 1024 个小文件中。这样，每个小文件最多包含 4MB 个 IP 地址；
3. 对于每一个小文件，可以构建一个 IP 为 key，出现次数为 value 的 Hash map，同时记录当前出现次数最多的那个 IP 地址；
4. 可以得到 1024 个小文件中的出现次数最多的 IP，再依据常规的排序算法得到总体上出现次数最多的 IP。

**从一个大文件中找出出现次数最多的 10 个 字符串，提供 1G 内存空间。**  
典型的 Top K 问题，解决方法是：
1. 先对这批海量数据预处理，在 O（N）的时间内用 Hash 表完成统计；
2. 借助堆这个数据结构，找出 Top K，时间复杂度为 N'logK。
即，借助堆结构，我们可以在 log 量级的时间内查找和调整/移动。因此，维护一个 K (该题目中是 10)大小的小根堆，然后遍历 300 万的 Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N'为300万）。

**从一个大文件中找出出现次数最多的 10 个 字符串，提供 1M 内存空间。**  
与上面的题目的区别就是可用内存更加小了，所有的数据不能一次性加载到内存中进行处理，所以我们要考虑分治思想：
1. 顺序读文件，对于每个字符串 x，取 hash(x)%5000，然后按照该值存到 5000 个小文件（记为 x0,x1,...x4999）中。这样每个文件大概是 200k 左右。
2. 如果其中的有的文件超过了 1M 大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过 1M。
3. 对每个小文件，可以通过 hash map 统计每个文件中出现的字符串以及相应的频率，并取出出现频率最大的 10 个字符串（可以用含 10 个结点的最小堆），并把 10 个字符串及相应的频率存入文件，这样又得到了 5000 个文件。
4. 对这 5000 个文件进行归并找出频率最大的 10 个字符串。

**给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，找出a、b文件共同的url？**  
 方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。  
 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。  
 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。  
求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

方案2：如果允许有一定的错误率，可以使用Bloom filter。

**如何给100亿个数字排序?**  
要给100亿个数字排序，100亿个 int 型数字放在文件里面大概有 37.2GB，非常大，内存一次装不下了。那么肯定是要拆分成小的文件一个一个来处理，最终在合并成一个排好序的大文件。

1. 把这个37GB的大文件，用哈希分成1000个小文件，每个小文件平均38MB左右（理想情况），把100亿个数字对1000取模，模出来的结果在0到999之间，每个结果对应一个文件，所以我这里取的哈希函数是 h = x % 1000，哈希函数取得"好"，能使冲突减小，结果分布均匀。
2. 拆分完了之后，得到一些几十MB的小文件，那么就可以放进内存里排序了，可以用快速排序，归并排序，堆排序等等。
3. 1000个小文件内部排好序之后，就要把这些内部有序的小文件，合并成一个大的文件，可以用二叉堆来做1000路合并的操作，每个小文件是一路，合并后的大文件仍然有序。
首先遍历1000个文件，每个文件里面取第一个数字，组成 (数字, 文件号) 这样的组合加入到堆里（假设是从小到大排序，用小顶堆），遍历完后堆里有1000个 (数字，文件号) 这样的元素。
然后不断从堆顶拿元素出来，每拿出一个元素，把它的文件号读取出来，然后去对应的文件里，加一个元素进入堆，直到那个文件被读取完。拿出来的元素当然追加到最终结果的文件里。  
按照上面的操作，直到堆被取空了，此时最终结果文件里的全部数字就是有序的了。

**认识布隆过滤器**  
如果遇到网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统等题目，又看到系统容忍一定程度额失误率，那么很可能就是考察布隆过滤器的知识。  
一个布隆过滤器精确的代表一个集合，并可以精确判断一个元素是否在集合中。注意，只是精确代表和精确判断，到底有多精确呢？则完全在于你具体的设计，但想做到完全正确是不可能的。布隆过滤器的优势在于使用很少的空间就可以将准确率做到很高的程度。  

首先介绍哈希函数的概念。哈希函数的输入域可以是非常大的范围，比如，任意一个字符串，但是输出域是固定的范围，假设为 S，并具有如下性质：

1. 典型的哈希函数都有无线的输入值域。
2. 当哈希函数传入相同的输入值时，返回值一样。
3. 当哈希函数传入不同的输入值时，返回值可能一样也可能不一样，这是正常的，因为输出域统一为 S，所以会有不同的输入值对应到 S 的一个元素上去。
4. 最重要的性质是许多不同的输入值所得到的返回值会均匀分布在 S 上。

第 1~3 点是哈希函数的基础，第 4 点是评价一个哈希函数优劣的关键，不同输入值所得到的所有返回值越均匀地分布在 S 上，哈希函数越优秀，并且这种均匀分布与输入值出现的规律无关。

接下来介绍一下什么是布隆过滤器。假设有一个长度为 m 的 bit 类型的数组，即数组中的每一个位置只占一个 bit，如我们所知，每一个 bit 只有 0 和 1 两种状态，如图所示：

![](/resource/bloom.png)

再假设一共有 k 个哈希函数，这些函数的输出域 S 都大于等于 m，并且这些哈希函数都足够优秀，彼此之间也完全独立。那么对同一个输入对象（假设是一个字符串记为 URL），经过 k 个哈希函数算出来的结果也是独立的，可能相同，也可能不同，彼此独立。对算出来的每个结果都对 m 取余（%m），然后在 bit array 上把相应的位置设置为 1（涂黑），如图所示：

![](/resource/bloom1.png)

我们把 bit 类型的数组称为 bitMap。至此，一个输入对象对 bitMap 影响过程就结束了，也就是 bitMap 的一些位置会涂黑。接下来按照该方法处理所有的输入对象，每个对象都可能把 bitMap 上的一些白位置涂黑，也可能遇到已经涂黑的位置，遇到已经涂黑的位置让其继续为黑即可。处理完所有的输入对象以后，可能 bitMap 中已经有相当多的位置被涂黑。至此，一个布隆过滤器完成，这个布隆过滤器代表之前所有输入对象组成的集合。

那么在检查阶段，如何检查某一个对象是否是之前的某一个输入对象呢？假设一个对象为 a，想检查它是否是之前的输入对象，就把 a 通过 k 个哈希函数算出 k 个值，然后把 k 个值取余，就得到 [0, m-1] 范围上的 k 个值。接下来在 bitMap 上看这些位置是不是都是黑的。如果有一个不为黑，说明 a 一定不在这个集合里。如果都为黑，说明 a 在这个集合里，但是可能有误判。再解释具体一点，如果 a 的确是输入对象，那么在生成布隆过滤器时，bitMap 相应的 k 个位置一定已经被涂黑了，所以在检查阶段，a 一定不会被漏过，这个不会产生误判。会产生误判的是，a 明明不是输入对象，但如果在生成布隆过滤器的阶段因为输入对象过多，而 bitMap 过小，则会导致 bitMap 绝大多数的位置都已经变黑。那么在检查 a 时，可能 a 对应的 k 个位置都是黑的，从而错误的认为 a 是输入对象。通俗地说，布隆过滤器的失误类型是『宁可错杀三千，绝不放过一个』。

**只用 2GB 内存在 20 亿个整数中找到出现次数最多的数**

![](/resource/bigdata.jpg)

**40 亿个非负整数中找到没出现的数**

![](/resource/bigdata2.jpg)

**40 亿个非负整数中找到出现两次的数和所有数的中位数**

![](/resource/bigdata3.jpg)

## 数组
**二维数组中，行递增，列递增，输入一个整数，判断数组中是否存在**  
首先看到这个题目，最直观的方法就是暴力求解，依次遍历整个数组，时间复杂度是 O(n)。  
然后我们根据题目中的条件，行递增，列递增，那么如果我们从右上角开始比较，如果当前值比较之后并且不等于输入值的时候，我们可以排除一整行或者一整列的内容，这样就避免了对整个数组的遍历。

**调整数组顺序使奇数位于偶数的前面**  
正常思路，从前往后遍历，遇到奇数的话看前面一位是否是偶数，如果是偶数的话就交换，交换完之后继续看前面一位是否是偶数，这样一直到前面一位是奇数为止。

**输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字**  
从左上角开始，按照上右下左四个方位分别循环。

**找出数组中出现次数超过一半的数字**  
首先分析如果某个数字在数组中超过一半，那么可以确定当这个数组排序之后，其中位数就一定是这个数字，所以我们可以相处一个最直观的做法，使用快排给这个数组排序，取其中位数即可，时间复杂度是 O(nlogn)。

除了上面的方法我们还可以根据这个数组的特征来解决：一个数字出现的次数超过超过整个数组长度的一半，如果我们遍历整个数组，遇到一个数字就将其记录下来，同时记其出现次数为 1，遍历到下一个数字的时候，如果这个数字跟记录的数字相同就加 1，不同就减 1，当减到 0 的时候就设置新的值，这样循环下去，最后这个设置的值一定是数组中出现次数超过一半的数字。

除了正常情况我们还要考虑特殊情况，如果这个数组中没有出现次数超过一半的数字怎么办？输出什么内容？这些都需要做检查。

**输入 n 个整数，找出其中最小的 k 个数**  
常规方法是使用快排找出其最小的 k 个数。

第二种解法适用于大数据量，可以使用最大堆这种数据结构，每次可以在 O(1) 的时间得到这 k 个数字的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的 k 个整数之一，于是我们可以抛弃这个整数。如果待插入的值比当前已有的最大值小，则用这个数值替换已有的最大值，可以在 O(logk) 时间内实现这个操作，因此对于 n 个输入数字而言，总得时间复杂度就是 O(nlogk)。

**连续子数组的最大和，要求时间复杂度是 O(n)**  
定义两个变量，一个是总和，一个是最大总和，在遍历的过程中，总和是一直变化的，可能变大也可能变小。而最大总和总是最大的，并且仅当总和大于最大总和的时候更新最大总和的值为总和。而总和在一直加的过程中，如果连续加了几个负数，导致结果小于零，那么我们就可以抛弃前面的和，而是从当前这个值重新开始加。并且注意最大总和的初始值应当取最小的负数：0x80000000，因为可能这个数组都是负数。

**将一个正整数数组所有的数字当做字符串一样随机排列，找出排列出的最小的一个数**  
这个题目是将数字拼接起来比较大小，所以需要考虑数字 m 和 n 拼接以后的结果 mn 和 nm 的大小。如果 mn < nm，那么应该输出 mn；反之应该输出 nm。我们可以根据这个定义一个比较规则，就是通过比较 m+""+n 和 n+""+m 的大小来确定 m 和 n 的大小顺序，在 Java 中比较器是通过 Comparator 实现的，默认小的在前面大的在后面，而对一个集合排序通过 Collections.sort 来实现。

**数组中如果位于前面的某个数字大于位于后面的某个数字，就说这是一组逆序对，求数组中逆序对的总数**  
暴力解法：没扫描到一个数字，逐个比较该数字和它后面的数字的大小，确定逆序对。这样的时间复杂度是 O(n^2)。

另一种解法很难想到，就是利用归并排序的思想，分析下来其实这个题目跟归并排序的过程完全一直。

**求出一个数字在一个排好序的数组中出现过几次**  
看到排序二字，立刻想到可以使用二分查找来解决这个问题。既然要求出某个数字 k 在数组中有几个，那么我们可以先找出第一个 k 的位置，然后再找出最后一个 k 的位置，那么 k 出现过几次也就呼之欲出了。

如果求第一个 k 的位置呢？使用二分查找的方法。可以将中间的数和 k 做比较，如果比 k 大，说明 k 只能在数组的前半部分，反之在后半部分。如果中间的数等于 k，那么我们需要判断这个数字是不是第一个 k 的位置，判断的方法就是看中间数字的前一个数字是不是 k。如果前一个数字不是 k，说明中间的数是第一个 k，否则说明第一个 k 肯定在数组的前半段，我们需要继续递归查找。

上面是分析如何得到第一个 k 的位置的方法，得到最后一个 k 的位置可以类似处理。

**一个整形数组中除了两个数字之外，其他的数字都出现了两次，请找出这两个只出现依次的数字**  
想要解决这个题目首先需要知道一个只是：任何一个数字异或它自己都等于 0。如果题目中不是两个数字只出现了一次，而是只有一个数字只出现了一次，那么我们把数组所有的数字异或以后的结果就是要求的这个数字。

但是现在题目是有两个只出现了一次的数字，如何举一反三呢？我们可以考虑把这个数组分成两个子数组，这两个只出现了一次的数组分别分配到一个子数组中，然后分别异或即可。那么如果分配到两个子数组中呢？异或的特征就是如果同一位两个数字不同，那么异或的结果就是 1，否则就是 0。我们可以从头到尾依次异或数组中的每一个数字，最终结果就是只出现过一次的两个数字的异或结果，并且肯定不为 0，我们可以找到第一个为 1 的位的位置，记为第 n 位，现在我们根据第 n 位是不是 1 为标准把原数组中的数字分成两个子数组即可。

**输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使它们的和正好为 s，如果有多对数字的和等于 s，输出两个数的乘积最小的**  
维护两个指针，一个在数组的开头，一个在数组的结尾，分别遍历这两个指针，知道它们相遇。

**输入一个整数 s，打印出所有和为 s 的连续正数序列（至少包含两个数）**  
同样是维护两个指针，分别初始化为 1 和 2，然后增大 big 的值，如果增大到序列和大于 s 了，就要去掉序列中较小的值，也就是增大较小指标的值，循环结束的位置是 small 增加到 (1+s)/2 为止。


**从扑克牌中随机抽 5 张牌，判断这 5 张牌是不是一个顺子，注意大小王可以看做任意数字**  
我们可以把大小王当做 0，首先排序，如果排序之后的数组不是连续的，则可以用 0 来补，只要 0 的数量大于等于空缺的数量，就可以组成一个顺子，另外注意如果非 0 数字有重复的情况，说明这副牌中存在对子，这种情况不可能是顺子。

**长度为 n 的数组中所有数字都在 0 到 n-1 范围内，数组中某些数字是重复的，请找出任意一个重复的数字**  
最简单的方法是先排序，然后找出重复数字。  
第二个方法是使用哈希表来实现。  
第三个方法就是归位法，因为数组中的数字范围使 0 到 n-1，如果我们让每个数字都归位到其对应下标的位置，最后肯定有要重复的数字，一次归位每一个数字，最后总是可以找到这个重复的数字。

## 树
*二叉搜索树特点：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点，我们可以在平均 O(logn) 的时间内根据数值在二叉搜索数中找到一个结点。*

**输入某二叉树的前序遍历和中序遍历的结果，重建出该二叉树**  
前序遍历数组的第一个元素一定是这个二叉树的根结点，而中序遍历的顺序是“左->中->右”，因此可以通过这两个信息找到二叉树的前半部分，根结点和后半部分，然后递归重建即可。

**输入两棵二叉树A，B，判断B是不是A的子结构**  
通过递归法来做：首先递归在 A 中找到和 B 的根结点的值一样的结点 R，然后再递归判断 A 中以 R 为根结点的子树是不是包含和树 B 一样的结构。

**给定一个二叉树，求这个二叉树的镜像**  
第一步就是交换这棵树的左右子结点，然后再递归得到左右子结点的镜像。

**从上往下打印出二叉树的每个节点，同层节点从左至右打印。**  
这个题目需要引入队列来辅助解决，首先把根结点放入队列，然后打印根结点，这个时候再把左右结点放入队列，再打印左右结点，按照上面的规则，总结起来就是，首先把根结点入队列，然后只要队列不为空，弹出当前结点的元素并打印，然后把当前结点的左右子结点入队列即可。

**输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。**  
首先根据二叉搜索数的特点找出根结点，然后递归判断左右子树是否是后序遍历，递归结束的标志是到达叶子结点。

**输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径**  
维持一个表示路径的集合，每次进入一个结点，就把这个结点放入集合中，判断结束以后再删除这个元素，然后递归判读左右子结点。

**输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。**  
当要将二叉搜索树转换成排序的双向链表时，原先指向左子结点的指针可以调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向后一个结点的指针。对于左右子树可以通过递归来实现，具体的过程就是：首先对左子结点转换并且得到转换后双向链表的头结点，然后遍历到这个双向链表的尾部，从而可以将 root 追加到该左子树对应的链表，然后再对右子树做转换，得到右子树的双向链表的头结点，然后将这个链表追加到 root 之后，最后返回左链表的头结点，左子树不存在的话就返回 root 结点。

**输入一棵二叉树，求该树的深度。**  
这个题目很简单，用递归实现，如果一棵树只有一个结点，那么它的深度就是 1；如果根结点只有左子树，那么深度就是左子树的深度加 1；如果根结点只有右子树，那么深度就是右子树的深度加 1；如果既有左子树又有右子树，那么该树的深度就是其左、右子树深度的较大值加 1。

**输入一棵二叉树，判断该二叉树是否是平衡二叉树。**  
这个题目也是用递归，但是注意应当从下往上递归，即先比较左右结点的深度，所以可以很容易想到通过后续遍历的方式去递归，递归结束的标志就是到达叶子结点。

**请实现一个函数，用来判断一颗二叉树是不是对称的。**  
递归实现：左右完全相同。

## 字符串
**将字符串中的空格替换成 `%20`**  
这个题目如果告知不能新建一个数组而是只能在原来的数组上面操作，那么有两种做法。  
第一种是从前往后替换，这样的时间复杂度是 O(n^2)；第二种是从后往前替换，即先求出替换之后的数组的长度，然后从后往前替换，这样的时间复杂度是 O(n)。

**输入一个字符串,按字典序打印出该字符串中字符的所有排列**  
可以把一个字符串看成是由两部分组成：第一部分是它的第一个字符，第二部分是后面的字符。我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换，然后第二步固定第一个字符，递归求后面所有字符的排列，但是注意一点，如果第一个字符已经出现过了，交换的字符必须与之不同，否则排列可能会重复。

**在字符串中找出第一个只出现依次的字符**  
题目不难需要使用一个类似于哈希表的 k-v 类型的数据结构，但是这里考虑到输入都是常规的字符串而没有特殊字符，所以他们都是 ASCII 码，也就是可以转换成对应的数字，所以我们可以定义一个长度是 256 的整型数组，用字符转换成的数字作为下标，这个字符出现的次数作为这个元素的值，最后遍历第一个值为 1 的即可。

**翻转一个句子中单词的顺序**  
第一步翻转句子中所有的字符，第二步翻转每个单词中的字符，这样就实现了翻转一个句子中单词的顺序。

**输入一个字符串和一个数字，在这个数字下标的位置做左旋转**  
我们把前 n 个字符分到第一部分，后面的所有字符分到第二部分，然后分别翻转这两部分，接下来再翻转整个字符串就实现了字符串的左旋转。

**将一个字符串转换成一个整数**  
看似简单的一道题目实则很不容易做对：要考虑空字符串的情况，要考虑输入只有一个正号或者负号的情况，还要考虑其他非数字字符串输入的情况，以及上下溢出问题。

## 链表
**给定一个单向链表的头指针和一个结点指针，在 O(1) 时间删除该结点。**  
正常删除一个结点我们需要从头开始遍历过去，还有一种思路是我们可以先得到要删除的结点的下一个结点，如果我们把下一个结点的内容复制到需要删除的结点上覆盖原有的内容，再把下一个结点删除，那就相当于把当前需要删除的结点删除了。但是还需要注意一点，如果给定的要删除的结点就是链表的最后一个结点，即它没有下一个结点，这个时候还是需要总头结点开始遍历。

**求出一个链表的倒数第 k 个结点**  
普通思路是假设链表有 n 个结点，那么倒数第 k 个基点就是正数第 n-k+1 个结点，所以我们只要先遍历依次链表得到链表的总数 n，然后从头结点开始往后走 n-k+1 步即可。  
更好的做法是维持两个指针，第一个指针先向前走 k-1 步，然后从第 k 步开始，两个指针一起走，这样当第一个指针到达链表尾部时，第二个指针正好到达倒数第 k 个结点。这种方法注意 k 的值不能大于链表中结点的个数。

**反转链表**  
反转的过程中我们需要把指向下一个结点的指针改成指向上一个结点，所以我们需要在遍历的过程中把上一个结点保存下来。

**合并两个排序的链表**  
典型的使用递归来解决：首先把两个链表的头结点值比较一下，确定新的链表的头结点，然后递归合并剩下的链表，`mergedList.next = Merge(list1, list2.next)`

**输入一个链表的头结点，从尾到头反过来打印链表**  
链表正常情况下都是从头到尾的，现在要实现的是从尾到头，我们可以很容易想到这是典型的“后进先出”，所以可以通过栈这个数据结构来实现。

**输入两个链表，找出它们的第一个公共结点**  
第一解决方法就是蛮力法：在第一个链表上遍历每个点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点，看是否相同。  
我们需要分析有公共结点的两个链表有哪些特点，由于两个链表都是单向链表，如果它们有公共的结点，那么一定是开始两个链表是分开的，然后从这个公共结点开始指向了同一个结点，并且它们之后的所有结点都是重合的，不可能出现分叉。形状就是 Y 形的。  
那么如何解决呢，我们可以先遍历两个链表得到它们的长度，就知道哪个链表比较长，以及长了多少个结点。然后第二次遍历的时候，可以先在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。

**给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。**  
本题目的解决思路是可以考虑分别移动两个指针，假设我们直到这个环中的结点数是 n，那么让指针 1 先移动 n 步，然后两个指针一起移动，则当第二个指针指向环的入口结点是，第一个指针已经绕环走了一圈并且也指向了这个入口结点。那么现在的问题就是如何过去环中的结点数，我们可以用一快一慢两个指针，如果两个指针相遇，说明链表中有环，然后从这个结点出发，一边移动一边计数，当再次回到这个结点，就可以得到环中的结点数了。

**在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。**
可以用递归的方法来解决。


## 栈和队列
**用两个栈实现一个队列**  
入队列操作是进入其中的一个栈中，出队列的操作是先把另一个栈排空，空了之后才从第一个栈中拉取新的元素。并且注意如果队列为空的时候给出异常提示。

**定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数**  
这个题目需要两个栈来实现，一个是所有数字正常入的栈，一个是记录最小元素的辅助栈，应当保证当入栈时，每次向正常栈弹入元素时，也要把最小值弹入到辅助栈中，出栈时这两个栈都要相应弹出元素，这样 min 函数取到辅助栈的栈顶元素一直都是最小值。

**输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序**  
需要一个辅助栈来帮助解决这个问题，基本思路是遍历压入顺序的序列，遇到一个元素就把这个元素压入栈，然后看弹出序列中的元素是否和栈顶元素相同，相同的话就弹出，不相同的话继续遍历压入顺序的序列，这样遍历完压入顺序的序列以后，如果弹出顺序是正确的话，最后这个辅助栈中应该是没有元素的，即为空。

## 位运算
**求一个整数的二进制表示中 1 的个数**  
常规做法是找一个标志数 1，将 1 与这个数的二进制的最后一位做与运算来确定其是不是 1，然后对 1 左移一位，再与这个数的第二位做与运算来确定是不是 1，这样做 32 次与运算就可以了。  
更好的做法是利用一个规则：把一个整数减去 1 之后再和原来的整数做与运算，得到的结果相当于是把整数的二进制表示中最右边一个 1 变成 0。我们可以将这个操作不停地作用在这个数上，知道这个数变成 0 为止。


## 回溯法

## 动态规划

## 其他
**实现斐波那契数列**  
斐波那契数列需要用到前两项，所以这个题目注意的一点是要保存这两项的值，避免递归可能导致的重复计算问题。

**一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）**  
跳第 1 级台阶，有一种跳法；跳第 2 级台阶，有两种跳法；跳第 n 级台阶，如果第一次跳了 1 级，那么剩下的台阶有 f(n-1) 种跳法，如果第依次跳了 2 级，那么剩下的台阶有 f(n-2) 种跳法，所以总共有 f(n-1)+f(n-2) 种跳法。

**变态跳台阶：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法**  
每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况。

**求一个数的整数次方，即求 base 的 exponent 次方**  
这个题目要注意这个数 base 可能是整数，也可能是浮点数，可能是整数，也可能是负数，也可能是 0。同时 exponent 可能是正整数也可能是负整数也可能是 0。如果 exponent 是负数，我们就需要求 base 的倒数，但是注意这个时候如果 base 是 0，求倒数是无意义的，所以需要做异常处理。

**打印 1 到最大的 n 位数**  
使用递归的方法来解决：我们把数字的每一位都从 0 到 9 排列一遍，就得到了所有的十进制数，递归结束的条件是我们已经设置了数字的最后一位。还有一点要注意的是数字排在前面的 0 不要打印出来。

**输入一个整数 n，求从 1 到 n 这 n 个整数的十进制表示中 1 出现的次数**  
普通方法是对每个数字做除法和求于运算以求出该数字中 1 出现的次数，如果输入数字 n，n 有 O(logn) 位，我们需要判断每一位是不是 1，那么它的时间复杂度是 O(nlogn)，当 n 非常大的时候，运算效率不高。

**约瑟夫环问题：0，1，……，n-1 这 n 个数字排成一个圆圈，从数字 0 开始每次从这个圆圈里删除第 m 个数字，求出这个圆圈里剩下的最后一个数字。**  
在 Java 中用 LinkedList 作为链表模拟这个环，首先把所有的元素放入环内，然后每次求于即可，最重要的一行代码是：`index = (index + m - 1) % list.size()`。

**求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。**  
这道题目很巧妙，使用了递归来实现的求和，递归结束的条件是逻辑与：`boolean flag = (n > 0) && ((sum += Sum_Solution(n - 1)) > 0)`。

**写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。**  
这个题目分几步走：第一步首先数字的各位加起来，但是不产生进位，这个可以通过异或操作来实现，第二步是产生进位，这个可以通过与操作，第三部将这个进位通过第一步产生的值再操作，这样一直循环，直到没有产生进位为止。

**请实现一个函数用来找出字符流中第一个只出现一次的字符。**  
本题目在 Java 中可以使用 HashMap 来记录字符的重复数，然后遍历 HashMap 即可。
