如果不是面专门的算法类岗位，面试最高频问题是这几类：大数据、数组、树、查找和排序，其中查找和排序最经常考的就是快排和二分查找了，一定要任何时候都可以手写出来。  
如果时间实在不够，就把上面提到的内容重点过一下，临阵磨枪，不亮也光。  
刷题除了答案本身有意义之外更重要的是解决的过程，把如何思考的过程记录下来，这样就可以总结出一些规律，有了思路以后写代码还是比较简单的，当然不排除某些比较难或者过程比较复杂的题目，这个时候还应当记录一下代码上的一些小彩蛋。  
这里的题目主要来源是 [剑指 offer](https://book.douban.com/subject/6966465/)，[程序员代码面试指南](https://book.douban.com/subject/26638586/)，[leetcode](https://leetcode.com)。
## 查找与排序

## 大数据
**从一个大文件中找出出现次数最多的 IP，假设只提供 1G 的内存空间。**  
1. IP 地址最多有 2^32=4G 种取值情况，所以不能完全加载到内存中处理；
2. 可以考虑采用“分而治之”的思想，按照 IP 地址的 Hash(IP)%1024 值，把海量IP日志分别存储到 1024 个小文件中。这样，每个小文件最多包含 4MB 个 IP 地址；
3. 对于每一个小文件，可以构建一个 IP 为 key，出现次数为 value 的 Hash map，同时记录当前出现次数最多的那个 IP 地址；
4. 可以得到 1024 个小文件中的出现次数最多的 IP，再依据常规的排序算法得到总体上出现次数最多的 IP。

**从一个大文件中找出出现次数最多的 10 个 字符串，提供 1G 内存空间。**  
典型的 Top K 问题，解决方法是：
1. 先对这批海量数据预处理，在 O（N）的时间内用 Hash 表完成统计；
2. 借助堆这个数据结构，找出 Top K，时间复杂度为 N'logK。
即，借助堆结构，我们可以在 log 量级的时间内查找和调整/移动。因此，维护一个 K (该题目中是 10)大小的小根堆，然后遍历 300 万的 Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N'为300万）。

**从一个大文件中找出出现次数最多的 10 个 字符串，提供 1M 内存空间。**  
与上面的题目的区别就是可用内存更加小了，所有的数据不能一次性加载到内存中进行处理，所以我们要考虑分治思想：
1. 顺序读文件，对于每个字符串 x，取 hash(x)%5000，然后按照该值存到 5000 个小文件（记为 x0,x1,...x4999）中。这样每个文件大概是 200k 左右。
2. 如果其中的有的文件超过了 1M 大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过 1M。
3. 对每个小文件，可以通过 hash map 统计每个文件中出现的字符串以及相应的频率，并取出出现频率最大的 10 个字符串（可以用含 10 个结点的最小堆），并把 10 个字符串及相应的频率存入文件，这样又得到了 5000 个文件。
4. 对这 5000 个文件进行归并找出频率最大的 10 个字符串。

**给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，找出a、b文件共同的url？**  
 方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。  
 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。  
 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。  
求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

方案2：如果允许有一定的错误率，可以使用Bloom filter。

**如何给100亿个数字排序?**  
要给100亿个数字排序，100亿个 int 型数字放在文件里面大概有 37.2GB，非常大，内存一次装不下了。那么肯定是要拆分成小的文件一个一个来处理，最终在合并成一个排好序的大文件。

1. 把这个37GB的大文件，用哈希分成1000个小文件，每个小文件平均38MB左右（理想情况），把100亿个数字对1000取模，模出来的结果在0到999之间，每个结果对应一个文件，所以我这里取的哈希函数是 h = x % 1000，哈希函数取得"好"，能使冲突减小，结果分布均匀。
2. 拆分完了之后，得到一些几十MB的小文件，那么就可以放进内存里排序了，可以用快速排序，归并排序，堆排序等等。
3. 1000个小文件内部排好序之后，就要把这些内部有序的小文件，合并成一个大的文件，可以用二叉堆来做1000路合并的操作，每个小文件是一路，合并后的大文件仍然有序。
首先遍历1000个文件，每个文件里面取第一个数字，组成 (数字, 文件号) 这样的组合加入到堆里（假设是从小到大排序，用小顶堆），遍历完后堆里有1000个 (数字，文件号) 这样的元素。
然后不断从堆顶拿元素出来，每拿出一个元素，把它的文件号读取出来，然后去对应的文件里，加一个元素进入堆，直到那个文件被读取完。拿出来的元素当然追加到最终结果的文件里。  
按照上面的操作，直到堆被取空了，此时最终结果文件里的全部数字就是有序的了。

**认识布隆过滤器**  
如果遇到网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统等题目，又看到系统容忍一定程度额失误率，那么很可能就是考察布隆过滤器的知识。  
一个布隆过滤器精确的代表一个集合，并可以精确判断一个元素是否在集合中。注意，只是精确代表和精确判断，到底有多精确呢？则完全在于你具体的设计，但想做到完全正确是不可能的。布隆过滤器的优势在于使用很少的空间就可以将准确率做到很高的程度。  

首先介绍哈希函数的概念。哈希函数的输入域可以是非常大的范围，比如，任意一个字符串，但是输出域是固定的范围，假设为 S，并具有如下性质：

1. 典型的哈希函数都有无线的输入值域。
2. 当哈希函数传入相同的输入值时，返回值一样。
3. 当哈希函数传入不同的输入值时，返回值可能一样也可能不一样，这是正常的，因为输出域统一为 S，所以会有不同的输入值对应到 S 的一个元素上去。
4. 最重要的性质是许多不同的输入值所得到的返回值会均匀分布在 S 上。

第 1~3 点是哈希函数的基础，第 4 点是评价一个哈希函数优劣的关键，不同输入值所得到的所有返回值越均匀地分布在 S 上，哈希函数越优秀，并且这种均匀分布与输入值出现的规律无关。

接下来介绍一下什么是布隆过滤器。假设有一个长度为 m 的 bit 类型的数组，即数组中的每一个位置只占一个 bit，如我们所知，每一个 bit 只有 0 和 1 两种状态，如图所示：

![](/resource/bloom.png)

再假设一共有 k 个哈希函数，这些函数的输出域 S 都大于等于 m，并且这些哈希函数都足够优秀，彼此之间也完全独立。那么对同一个输入对象（假设是一个字符串记为 URL），经过 k 个哈希函数算出来的结果也是独立的，可能相同，也可能不同，彼此独立。对算出来的每个结果都对 m 取余（%m），然后在 bit array 上把相应的位置设置为 1（涂黑），如图所示：

![](/resource/bloom1.png)

我们把 bit 类型的数组称为 bitMap。至此，一个输入对象对 bitMap 影响过程就结束了，也就是 bitMap 的一些位置会涂黑。接下来按照该方法处理所有的输入对象，每个对象都可能把 bitMap 上的一些白位置涂黑，也可能遇到已经涂黑的位置，遇到已经涂黑的位置让其继续为黑即可。处理完所有的输入对象以后，可能 bitMap 中已经有相当多的位置被涂黑。至此，一个布隆过滤器完成，这个布隆过滤器代表之前所有输入对象组成的集合。

那么在检查阶段，如何检查某一个对象是否是之前的某一个输入对象呢？假设一个对象为 a，想检查它是否是之前的输入对象，就把 a 通过 k 个哈希函数算出 k 个值，然后把 k 个值取余，就得到 [0, m-1] 范围上的 k 个值。接下来在 bitMap 上看这些位置是不是都是黑的。如果有一个不为黑，说明 a 一定不在这个集合里。如果都为黑，说明 a 在这个集合里，但是可能有误判。再解释具体一点，如果 a 的确是输入对象，那么在生成布隆过滤器时，bitMap 相应的 k 个位置一定已经被涂黑了，所以在检查阶段，a 一定不会被漏过，这个不会产生误判。会产生误判的是，a 明明不是输入对象，但如果在生成布隆过滤器的阶段因为输入对象过多，而 bitMap 过小，则会导致 bitMap 绝大多数的位置都已经变黑。那么在检查 a 时，可能 a 对应的 k 个位置都是黑的，从而错误的认为 a 是输入对象。通俗地说，布隆过滤器的失误类型是『宁可错杀三千，绝不放过一个』。

**只用 2GB 内存在 20 亿个整数中找到出现次数最多的数**

![](/resource/bigdata.jpg)

**40 亿个非负整数中找到没出现的数**

![](/resource/bigdata2.jpg)

**40 亿个非负整数中找到出现两次的数和所有数的中位数**

![](/resource/bigdata3.jpg)

## 数组
**二维数组中，行递增，列递增，输入一个整数，判断数组中是否存在**  
首先看到这个题目，最直观的方法就是暴力求解，依次遍历整个数组，时间复杂度是 O(n)。  
然后我们根据题目中的条件，行递增，列递增，那么如果我们从右上角开始比较，如果当前值比较之后并且不等于输入值的时候，我们可以排除一整行或者一整列的内容，这样就避免了对整个数组的遍历。

**调整数组顺序使奇数位于偶数的前面**  
正常思路，从前往后遍历，遇到奇数的话看前面一位是否是偶数，如果是偶数的话就交换，交换完之后继续看前面一位是否是偶数，这样一直到前面一位是奇数为止。

**找出数组中出现次数超过一半的数字**  
首先分析如果某个数字在数组中超过一半，那么可以确定当这个数组排序之后，其中位数就一定是这个数字，所以我们可以相处一个最直观的做法，使用快排给这个数组排序，取其中位数即可，时间复杂度是 O(nlogn)。

除了上面的方法我们还可以根据这个数组的特征来解决：一个数字出现的次数超过超过整个数组长度的一半，如果我们遍历整个数组，遇到一个数字就将其记录下来，同时记其出现次数为 1，遍历到下一个数字的时候，如果这个数字跟记录的数字相同就加 1，不同就减 1，当减到 0 的时候就设置新的值，这样循环下去，最后这个设置的值一定是数组中出现次数超过一半的数字。

除了正常情况我们还要考虑特殊情况，如果这个数组中没有出现次数超过一半的数字怎么办？输出什么内容？这些都需要做检查。

**输入 n 个整数，找出其中最小的 k 个数**  
常规方法是使用快排找出其最小的 k 个数。

第二种解法适用于大数据量，可以使用最大堆这种数据结构，每次可以在 O(1) 的时间得到这 k 个数字的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的 k 个整数之一，于是我们可以抛弃这个整数。如果待插入的值比当前已有的最大值小，则用这个数值替换已有的最大值，可以在 O(logk) 时间内实现这个操作，因此对于 n 个输入数字而言，总得时间复杂度就是 O(nlogk)。

**连续子数组的最大和，要求时间复杂度是 O(n)**  
定义两个变量，一个是总和，一个是最大总和，在遍历的过程中，总和是一直变化的，可能变大也可能变小。而最大总和总是最大的，并且仅当总和大于最大总和的时候更新最大总和的值为总和。而总和在一直加的过程中，如果连续加了几个负数，导致结果小于零，那么我们就可以抛弃前面的和，而是从当前这个值重新开始加。并且注意最大总和的初始值应当取最小的负数：0x80000000，因为可能这个数组都是负数。

**将一个正整数数组所有的数字当做字符串一样随机排列，找出排列出的最小的一个数**  
这个题目是将数字拼接起来比较大小，所以需要考虑数字 m 和 n 拼接以后的结果 mn 和 nm 的大小。如果 mn < nm，那么应该输出 mn；反之应该输出 nm。我们可以根据这个定义一个比较规则，就是通过比较 m+""+n 和 n+""+m 的大小来确定 m 和 n 的大小顺序，在 Java 中比较器是通过 Comparator 实现的，默认小的在前面大的在后面，而对一个集合排序通过 Collections.sort 来实现。

**数组中如果位于前面的某个数字大于位于后面的某个数字，就说这是一组逆序对，求数组中逆序对的总数**  
暴力解法：没扫描到一个数字，逐个比较该数字和它后面的数字的大小，确定逆序对。这样的时间复杂度是 O(n^2)。

另一种解法很难想到，就是利用归并排序的思想，分析下来其实这个题目跟归并排序的过程完全一直。

**求出一个数字在一个排好序的数组中出现过几次**  
看到排序二字，立刻想到可以使用二分查找来解决这个问题。既然要求出某个数字 k 在数组中有几个，那么我们可以先找出第一个 k 的位置，然后再找出最后一个 k 的位置，那么 k 出现过几次也就呼之欲出了。

如果求第一个 k 的位置呢？使用二分查找的方法。可以将中间的数和 k 做比较，如果比 k 大，说明 k 只能在数组的前半部分，反之在后半部分。如果中间的数等于 k，那么我们需要判断这个数字是不是第一个 k 的位置，判断的方法就是看中间数字的前一个数字是不是 k。如果前一个数字不是 k，说明中间的数是第一个 k，否则说明第一个 k 肯定在数组的前半段，我们需要继续递归查找。

上面是分析如何得到第一个 k 的位置的方法，得到最后一个 k 的位置可以类似处理。

**一个整形数组中除了两个数字之外，其他的数字都出现了两次，请找出这两个只出现依次的数字**  
想要解决这个题目首先需要知道一个只是：任何一个数字异或它自己都等于 0。如果题目中不是两个数字只出现了一次，而是只有一个数字只出现了一次，那么我们把数组所有的数字异或以后的结果就是要求的这个数字。

但是现在题目是有两个只出现了一次的数字，如何举一反三呢？我们可以考虑把这个数组分成两个子数组，这两个只出现了一次的数组分别分配到一个子数组中，然后分别异或即可。那么如果分配到两个子数组中呢？异或的特征就是如果同一位两个数字不同，那么异或的结果就是 1，否则就是 0。我们可以从头到尾依次异或数组中的每一个数字，最终结果就是只出现过一次的两个数字的异或结果，并且肯定不为 0，我们可以找到第一个为 1 的位的位置，记为第 n 位，现在我们根据第 n 位是不是 1 为标准把原数组中的数字分成两个子数组即可。

**输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使它们的和正好为 s，如果有多对数字的和等于 s，输出两个数的乘积最小的**  
维护两个指针，一个在数组的开头，一个在数组的结尾，分别遍历这两个指针，知道它们相遇。

**输入一个整数 s，打印出所有和为 s 的连续正数序列（至少包含两个数）**  
同样是维护两个指针，分别初始化为 1 和 2，然后增大 big 的值，如果增大到序列和大于 s 了，就要去掉序列中较小的值，也就是增大较小指标的值，循环结束的位置是 small 增加到 (1+s)/2 为止。


**从扑克牌中随机抽 5 张牌，判断这 5 张牌是不是一个顺子，注意大小王可以看做任意数字**  
我们可以把大小王当做 0，首先排序，如果排序之后的数组不是连续的，则可以用 0 来补，只要 0 的数量大于等于空缺的数量，就可以组成一个顺子，另外注意如果非 0 数字有重复的情况，说明这副牌中存在对子，这种情况不可能是顺子。

**长度为 n 的数组中所有数字都在 0 到 n-1 范围内，数组中某些数字是重复的，请找出任意一个重复的数字**  
最简单的方法是先排序，然后找出重复数字。  
第二个方法是使用哈希表来实现。  
第三个方法就是归位法，因为数组中的数字范围使 0 到 n-1，如果我们让每个数字都归位到其对应下标的位置，最后肯定有要重复的数字，一次归位每一个数字，最后总是可以找到这个重复的数字。

## 树

## 字符串

## 链表

## 栈和队列

## 位运算

## 回溯法

## 动态规划

## 其他
