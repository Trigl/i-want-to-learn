# Java 内存区域与内存溢出异常
## 运行时数据区域
### 程序计数器
程序计数器是一块较小的内存空间，可以看作是当前线程执行的 **字节码的行号指示器**。

由于 Java 虚拟机中多线程是通过 **线程轮流切换** 并 **分配处理器执行时间** 的方式实现的，所以任何一个确定的时刻，一个处理器只会执行一条线程中的指令，程序计数器就是记录这条指令对应的地址，因此各个线程之间的计数器互补影响，线程计数器是 **线程私有内存**。

如果线程执行的是 Java 方法，计数器记录的是正在执行的 **虚拟机字节码地址**；如果执行的是 Native 方法，计数器值为空（Undefined）。

> 线程技术器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。为什么？

### Java 虚拟机栈
线程私有。每个方法执行的时候都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。

其中局部变量表存放了 **编译期** 可知的 **各种基本数据类型**、**对象引用** 和 **returnAddress类型（指向字节码指令的地址）**。

64 位的 long 和 double 数据占用 2 个局部变量空间（Slot），局部变量表所需内存在 **编译期间** 完成分配，因此进入一个方法需要在栈帧中分配多大的局部变量空间 **完全确定**。

虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，抛出 `StackOverflowError` 异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 `OutOfMemoryError` 异常。

> 操作数栈、动态链接、方法出口具体存放什么信息？

### 本地方法栈
与 Java 虚拟机栈类似。

### Java 堆
在虚拟机 **启动** 时创建，会抛出 OOM 异常。

> 什么是栈上分配？什么是标量替换？

> Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB），TLAB 是什么？

### 方法区
方法区（HotSpot 也称为永久代）存储 **已被虚拟机加载** 的类信息、常量、静态变量、即时编译器编译后的代码等数据。也会抛 OOM 异常。

> 即时编译器编译后的代码是什么数据？

> 方法区如何进行 GC？

运行时常量池是方法区的一部分，存放编译器生成的各种 **字面量和符号引用**。运行时常量池的另一个重要特性是具有动态性，除了编译期间的内容，运行期间也可能将新的常量放入池中。

> String 类的 intern() 方法如何利用运行时常量池的动态性？

### 直接内存
并不是虚拟机运行时数据区的一部分，但是也会抛出 OOM 异常。

JDK 1.4 中新加入了 NIO 类，引入了一种基于 **通道（Channel）和缓冲区（Buffer）** 的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为 **避免了在 Java 堆和 Native 堆中来回复制数据**。

直接内存分配不受 Java 堆大小限制，但是受到本机总内存大小限制。

## HotSpot 虚拟机对象探秘
### 对象的创建
虚拟机遇到一条 new 指令，首先检查 **指令的参数** 是否能在常量池中定位到一个 **类的符号引用**，并且检查这个符号引用代表的类是否已被 **加载、解析和初始化**。

如果没有，执行 **类加载过程**。

类加载完成后，虚拟机将为新生对象 **分配内存**，对象所需内存大小在类加载完成后便可完全确定。

分配内存的方式有两种，根据 Java 堆 **是否规整** 来确定具体使用哪种。对于使用 Serial、ParNew 等带 Compact 过程的收集器，使用 **指针碰撞**，也就是直接移动相应指针分配内存即可。对于使用 CMS 这种基于 Mark-Sweep 算法的收集器，使用 **空闲列表**，也就是维护一个列表，记录哪些内存快是可用的，分配的时候找到一个足够大的空间。

在分配内存的时候还需要考虑并发情况下线程安全的问题，有两个解决方案：

- 对分配内存的动作进行 **同步处理**，虚拟机采用 **CAS** + **失败重试** 保证更新操作的原子性。
- 每个线程在 Java 堆预分配 TLAB，可以通过 -XX:+/-UseTLAB 参数来设定。

内存分配完后，虚拟机将分配的内存空间初始化为零值。如果使用了 TLAB，这一过程提前至 TLAB 分配时进行。

接下来，虚拟机会配置对象头的信息，具体包含 **类的元数据**、**对象的哈希码**、**对象的 GC 分代年龄** 等。

上面工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，new 操作刚刚执行，下一步就是执行 <init> 方法，按照我们在代码中定义的顺序初始化对象。

### 对象的内存布局
对象在内存中存储的数据有 3 部分：对象头，实例数据和对齐填充。

对象头包括两部分信息，第一部分用于存储对象自身的元数据信息，如 **哈希码**、**GC 分代年龄**、**锁状态标志**、**线程持有的锁**、**偏向线程 ID**，这部分数据的长度在 32 位和 64 位的虚拟机中分别位 32bit 和 64bit，官方称之为 `Mark Word`。

> 线程持有的锁是怎么存储的？偏向线程 ID 是什么？

对象头的另一部分是类型指针，即指向它的类元数据的指针，虚拟机通过这个指针来 **确定这个对象是哪个类的实例**。但是注意并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，**查找对象的类的元数据信息并不一定要经过对象本身**。另外，如果对象是数组，对象头中还必须有一块用于记录 **数组长度** 的数据。

实例数据部分存储程序代码中定义的各种类型的字段内容，无论从父类继承下来的，还是在子类中定义的，都需要记录下来。

这部分的存储顺序受到 **虚拟机分配策略参数** 和 **字段在 Java 源码中定义顺序** 的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配在一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。

第三部分对齐填充并不是必然存在的，仅仅起着占位符的作用，因为规定对象起始地址必须是 8 字节的整数倍，也就是对象大小必须是 8 字节的整数倍。

> 为什么对象头部分正好是 8 字节的 1 倍或者 2 倍，对象头用于存储对象自身的元数据信息就已经 32/64bit 了，类型指针不占用空间？

### 对象的访问定位
创建了对象以后就要使用对象，Java 程序是通过 **栈上的 reference 数据** 来操作堆上的具体对象。reference 类型只规定了一个 **指向对象的引用**，访问方式有两种方式。

**使用句柄**  
如果使用句柄访问，Java 堆中会划出一块内存来作为句柄池，reference 中存到的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如图：

![](/resource/handle.png)

使用句柄的好处就是 reference 存储的是稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

**使用直接指针**  
Java 堆对象的布局中必须能够存放对象类型数据的相关信息，而 reference 中存储的直接就是对象地址，如图：

![](/resource/pointer.png)

使用直接指针访问的最大好处就是速度更快，它节省了一次指针定位的时间消耗。
