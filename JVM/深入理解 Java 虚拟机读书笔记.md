# Java 内存区域与内存溢出异常
## 运行时数据区域
### 程序计数器
程序计数器是一块较小的内存空间，可以看作是当前线程执行的 **字节码的行号指示器**。

由于 Java 虚拟机中多线程是通过 **线程轮流切换** 并 **分配处理器执行时间** 的方式实现的，所以任何一个确定的时刻，一个处理器只会执行一条线程中的指令，程序计数器就是记录这条指令对应的地址，因此各个线程之间的计数器互补影响，线程计数器是 **线程私有内存**。

如果线程执行的是 Java 方法，计数器记录的是正在执行的 **虚拟机字节码地址**；如果执行的是 Native 方法，计数器值为空（Undefined）。

> 线程技术器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。为什么？

### Java 虚拟机栈
线程私有。每个方法执行的时候都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。

其中局部变量表存放了 **编译期** 可知的 **各种基本数据类型**、**对象引用** 和 **returnAddress类型（指向字节码指令的地址）**。

64 位的 long 和 double 数据占用 2 个局部变量空间（Slot），局部变量表所需内存在 **编译期间** 完成分配，因此进入一个方法需要在栈帧中分配多大的局部变量空间 **完全确定**。

虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，抛出 `StackOverflowError` 异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 `OutOfMemoryError` 异常。

> 操作数栈、动态链接、方法出口具体存放什么信息？

### 本地方法栈
与 Java 虚拟机栈类似。

### Java 堆
在虚拟机 **启动** 时创建，会抛出 OOM 异常。

> 什么是栈上分配？什么是标量替换？

> Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB），TLAB 是什么？

### 方法区
方法区（HotSpot 也称为永久代）存储 **已被虚拟机加载** 的类信息、常量、静态变量、即时编译器编译后的代码等数据。也会抛 OOM 异常。

> 即时编译器编译后的代码是什么数据？

> 方法区如何进行 GC？

运行时常量池是方法区的一部分，存放编译器生成的各种 **字面量和符号引用**。运行时常量池的另一个重要特性是具有动态性，除了编译期间的内容，运行期间也可能将新的常量放入池中。

> String 类的 intern() 方法如何利用运行时常量池的动态性？

### 直接内存
并不是虚拟机运行时数据区的一部分，但是也会抛出 OOM 异常。

JDK 1.4 中新加入了 NIO 类，引入了一种基于 **通道（Channel）和缓冲区（Buffer）** 的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为 **避免了在 Java 堆和 Native 堆中来回复制数据**。

直接内存分配不受 Java 堆大小限制，但是受到本机总内存大小限制。
