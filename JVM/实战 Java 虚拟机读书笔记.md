# 初探 Java 虚拟机
虚拟机是一款软件，用来执行一系列虚拟计算机指令。  
虚拟机分为系统虚拟机和程序虚拟机，系统虚拟机是对物理计算机的仿真，提供了可运行完整操作系统的软件平台，如 VMware；程序虚拟机专门为执行单个计算就程序而设计，最著名的就是 Java 虚拟机。

# 认识 Java 虚拟机的基本结构  
Java 虚拟机的基本结构如图：

![](/resource/jvm-arc.png)

- 类加载子系统：从文件系统或者网络中加载 Class 信息，加载的**类信息**存放在一块称为方法区的**内存空间**。除了类信息，方法区还可能存放**运行时常量池**信息。  
- Java 堆：在虚拟机**启动**的时候建立，是 Java 程序**最主要的内存**工作区域。几乎所有的 **Java 对象实例**都存放在这里，堆空间是**所有线程共享的**。
- 直接内存：是 **Java 堆外**的、**直接向系统申请**的内存空间，Java 的 **NIO 库**允许 Java 程序使用直接内存。**速度优于 Java 堆**，因此读写频繁的场景可以考虑使用直接内存。而且大小**不会受限于 Xmx 指定的最大堆大小**。  
- 垃圾回收系统：可以对**方法区、Java 堆和直接内存**进行回收，当然，**Java 堆**是其回收的重点对象。  
- Java 栈：每一个 Java 虚拟机**线程**都有一个**私有**的 Java 栈，在**线程创建**的时候被创建。Java 栈中保存着**帧信息**，Java 栈中保存着**局部变量、方法参数**，和 Java 方法的调用和返回密切相关。  
- 本地方法栈：和 Java 栈很类似，最大的不同是 Java 栈用于 **Java 方法**的调用，而本地方法栈用于**本地方法**的调用，本地方法一般是 C 语言编写。  
- PC（Program Counter）寄存器：也是线程私有空间，任意时刻一个 Java 线程总是在执行一个方法，这个正在被执行的方法称为**当前方法**。如果当前方法不是本地方法，PC 就会指向**当前正在被执行的指令**，如果当前方法是本地方法，PC 的值就是 undefined。  
- 执行引擎：执行虚拟机中的**字节码**。

## Java 栈
每一次**函数调用**，都会有一个对应的**栈帧**被压入 Java 栈，每一个函数调用结束，都会有一个栈帧被弹出 Java 栈。Java 方法有两种返回函数的方式，一种是正常的通过 return 指令返回，另一种是抛出异常，不论哪种方式，都会导致栈帧被弹出。

Java 栈空间的大小可以通过设置 `-Xss` 来指定，每一次入栈的栈帧都会占用一定的栈空间，如果函数调用太多，当请求的栈深度大于最大栈深度是，系统就会抛出 StackOverflowError 栈溢出错误。

再来讲一下栈帧中的内容，一般必须包含局部变量表、操作数栈和帧数据区这几个部分。

**局部变量表**  
局部变量表用来保存**函数的参数和局部变量**，因此函数的参数和局部变量越多，局部变量表越大，占用的栈空间就越多。  
我们可以使用 `jclasslib` 工具更进一步查看函数的局部变量信息，可以通过 `Maximum local variables` 查看局部变量表占了几个字，字（word）指的是计算机内存中占据一个单独的内存单元编号的一组二进制串，一般 32 位计算机上一个字为 4 个字节长度，即 32 bit，所以一个 int 类型是一个字，一个 long 类型是两个字。  

*疑问：Class 文件的局部变量表和 Java 栈中的局部变量表这两个概念有什么区别？*  
Class 文件中的局部变量表是 Class 文件的一个属性，可以显示栈帧中局部变量表的每个局部变量的作用域范围、所在槽位的索引（index 列）、变量名（name 列）和数据类型。  
栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量**过了其作用域**，之后声明的新的局部变量（变量名不一定要相同）**很有可能**会复用过期局部变量的槽位，从而节省资源。

局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中**直接或间接引用**的对象都是不会被回收的。我们可以使用参数 `-XX:+PrintGC` 来查看垃圾回收的过程。

**操作数栈**  
操作数栈用来保存**计算的中间结果**，同时作为计算过程中变量临时的存储空间，比如 `iadd` 指令，它会在操作数栈中弹出两个整数并进行加法计算，计算结果会被入栈。  
这样说来它和局部变量表有什么区别呢，局部变量表存储局部变量，程序会使用这些局部变量并做一些计算，操作数栈就给这个**计算过程**中的变量提供一个暂存位置。

**帧数据区**  
帧数据区保存的数据与**常量池解析**、**正常方法返回**和**异常处理**有关。  
大部分的 Java 字节码指令需要进行常量池访问，在帧数据区中保存这访问常量池的指针，方便程序访问常量池。  
当函数返回或者出现异常时，栈帧内会有一个异常处理表告诉程序下一步应当如何进行。

**栈上分配**  
对于线程私有的对象（或者说是不可能被其他线程访问的对象），可以将它们打散分配在栈上，而不是分配在堆上，这样可以在函数调用结束后自动销毁，而不需要垃圾回收器的介入。  
那么哪些情况可以使用栈上分配呢？这就需要进行**逃逸分析**，目的是判断对象的作用域是否有可能逃逸出函数体。  
如下代码显示了一个逃逸对象：

```java
private static User u;
public static void alloc() {
    u = new User();
    u.id = 5;
    u.name = "geym";
}
```

对象 User u 是类的成员变量，可能被任何线程访问，因此属于逃逸对象，下面代码显示一个非逃逸对象：

```java
public static void alloc() {
    User u = new User();
    u.id = 5;
    u.name = "geym";
}
```

这里对象 User u 是以局部变量的形式存在的，并且没有被函数 alloc 返回，因此并未逃逸，对于这种情况，虚拟机就可以将 User 分配在栈上，而不是堆上。

栈上分配需要开启两个参数，参数 `-XX:+DoEscapeAnalysis` 启用逃逸分析，参数 `-XX:+EliminateAllocations` 开启了标量替换（默认打开），允许将对象打散到栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段会被视为两个独立的局部变量进行分配。

栈上分配适合于**大量的零散小对象**的优化机制，但由于和堆空间相比，栈空间较小，因此大对象不适合在栈上分配。

## 方法区
方法区也是被所以线程共享的，保存系统的类信息，例如类的**字段、方法、常量池**等，方法区的大小决定了系统可以保存多少个类。  
JDK 1.6 和 JDK 1.7 中，方法区可以理解成永久区（Perm），可以使用参数 `-XX:PermSize` 和 `-XX:MaxPermSize` 指定初始永久区大小和最大永久区大小。如果系统使用了一些**动态代理**，那么有可能会在**运行时**生成大量的类，可能会导致永久区溢出。  
JDK 1.8 中，永久区已经被永久移除了，取而代之的是**元数据区**。元数据区的大小可以使用参数 `-XX:MaxMetaspaceSize` 指定，这是一块堆外的直接内存。与永久区不同的是，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常，异常信息为 `java.lang.OutOfMemoryError: Metaspace`。

# 常用 Java 虚拟机参数
## 跟踪垃圾回收
`-XX:+PrintGC`：打印最简略的 GC 日志。  

`-XX:+PrintGCDetails`：更加详细的 GC 信息。Full GC 会同时回收新生代、老年代和永久区。user 表示用户态 CPU 耗时，sys 表示系统 CPU 耗时，real 表示 GC 实际的时间。  
*疑问：用户态和系统有什么区别？*  
*疑问：下界、上界和当前上界有什么区别？*  

`-XX:+PrintHeapAtGC`：在每次 GC 前后分别打印堆的信息。

`-XX:+PrintGCTimeStamps`：输出 GC 发生的时间，输出时间为虚拟机启动后的时间偏移量。

`-XX:+PrintGCApplicationConcurrentTime`：打印应用程序的执行时间。

`-XX:+PrintGCApplicationStoppedTime`：打印应用程序由于 GC 而产生的停顿时间。

`-XX:+PrintReferenceGC`：跟踪系统内软引用、弱引用、虚引用和 Finalize 队列。

`-Xloggc:log/gc.log`：GC 日志记录在当前目录下 log 文件夹下的 gc.log 文件中。

## 跟踪类加载/卸载
可以使用 `-verbose:class` 跟踪类的加载和卸载，也可以单独使用 `-XX:+TraceClassLoading` 跟踪类的加载，使用 `-XX:+TraceClassUnloading` 跟踪类的卸载，这两者等价。

## 虚拟机系统参数的查看
`-XX:+PrintVMOptions`：打印虚拟机显式接收到的参数。  

`-XX:+PrintCommandLineFlags`：打印传递给虚拟机的显式和隐式参数，隐式参数可能是虚拟机启动时自行设置的。  

`-XX:+PrintFlagsFinal`：打印所有系统参数的值。

## 堆的配置参数
首先最常见的，用 `-Xms` 和 `-Xmx` 配置初始堆大小和最大堆大小，一个基本的理解是最大可用内存是 -Xmx 的取值，当前总内存不小于 -Xms 的值，因为总内存总是在 -Xms 和 -Xmx 之间，从 -Xms 开始根据需要上涨。实际上的内存比上面的值略小一点。  
在实际工作中可以直接将 -Xms 和 -Xmx 设置相等，这样可以减少程序运行时的垃圾回收次数。

`-Xmn`：新生代大小，一般设置为整个堆空间的 1/3 到 1/4 左右。

`-XX:SurvivorRatio`：新生代中 eden 空间和 from/to 空间的比例关系，默认值是 8，即如果 from 和 to 的空间各占 1 份，那么 eden 就占 8 份，整个新生代就占 10 份。

`-XX:NewRatio`：老年代和新生代的比例。

当堆溢出，即发生 OOM 的时候，我们应该配置哪些参数来排查问题进行处理呢？  
首先我们需要详细的现场信息来排查问题，可以使用 `-XX:+HeapDumpOnOutOfMemoryError` 导出整个堆的信息，使用 `-XX:HeapDumpPath=/path/error.dump` 来指定导出这个堆到哪个文件路径下面，然后我们可以使用 MAT 等工具打开该文件进行分析。  
同时我们还可以在 OOM 时跑一个脚本，用于奔溃程序自救、报警或存一些有用信息，使用方法是 `-XX:OnOutOfMemoryError=/path/alarm.sh`。

## 直接内存配置
最大可用直接内存可以使用参数 `-XX:MaxDirectMemorySize` 设置，如不设置，默认值为最大堆内存 -Xmx。当直接内存使用量达到 -XX:MaxDirectMemorySize 时，就会出发垃圾回收，如果垃圾回收不能有效释放足够空间，也会引起 OOM。  
*疑问：直接内存中如果进行垃圾回收？**

直接内存适合申请空间次数较少、读写较频繁的场合。如果内存空间本身需要频繁申请，则并不适合使用直接内存。

## 虚拟机的 client 和 server 模式
目前 Java 虚拟机支持 client 和 server 两种运行模式，分别使用 `-client` 和 `-server` 来指定。  
与 client 模式相比，server 模式的启动比较慢，因为 server 模式会尝试收集更多的系统性能信息，使用更复杂的优化算法对程序进行优化。因此，当系统完全启动并进入运行稳定期后，server 模式的执行速度会远远快于 client 模式，所以对于长期后台运行的系统，一般选择 server 模式，对于用户界面程序，运行时间不长又追求启动速度，一般选择 client 模式。

从发展趋势来看，未来 64 位系统必然会取代 32 位系统，而在 64 位系统中虚拟机更倾向于使用 server 模式运行。

# 垃圾回收概念和算法
垃圾回收，简称 GC，需要分两步进行，第一要知道什么是垃圾，第二才可以回收这些垃圾。首先看如何判断一个对象是否能够被回收。
## 如何判断哪些是垃圾？
垃圾回收的基本判断思想是看一个对象是否可达，可达的概念是从根对象进行引用搜索，最终是否可以到达这个对象，如果可以到达，我们就说这是可达对象，说明这个对象正在被使用，不是垃圾；如果最终不能到达这个对象，即这个对象没有被引用到，那么就说这是个不可达对象，一般来说，此对象需要被回收。但事实上，一个不可达对象可能在某一条件下复活自己，如果是这样，那么对它的回收就是不合理的，那么到底怎样的对象才真正算一个垃圾呢，我们首先看一下站在垃圾回收的角度上对象的 3 种状态：

- 可触及的：从根对象开始，可以到达这个对象，即是一个可达对象。
- 可复活的：对象的所有引用都被释放，此时是不可达对象，但是该不可达对象有可能在 finalize() 函数中复活。
- 不可触及的：对象的 finalize() 函数被调用，但是没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为 finalize() 函数只会被调用一次。

以上三种状态，只有对象不可触及时才算真正的垃圾，才可以被回收。

*疑问：什么叫做根对象？从根对象引用搜索是什么意思？是指查看是否有指向搜索对象的引用吗？*  
*疑问：finalize() 函数是什么时候调用的？GC 的时候一定会调用吗？还是说调用时间不明确？*

当释放一个对象的引用时，这个对象就变成不可达了，如果此时进行第一次 GC，如果调用 finalize() 函数的时候，对象被复活（如通过 this 引用的方式），并且引用外泄（可以被外部访问），那么该对象就复活了，相反如果调用 finalize() 函数以后没有复活，由于 finalize() 只会被调用一次，那么第二次 GC 的时候，对象就会被直接回收。

**引用的强度和可触及性分析**  
Java 提供 4 个级别的引用：强引用、软引用、弱引用和虚引用。  
强引用是可触及的，不会被回收的。  
软引用是比强引用弱一点的引用类型，当堆空间不足时，软引用对象就会被回收，所以软引用不会引起内存溢出。  
弱引用又比软引用弱，只要系统 GC，发现了弱引用，不管堆空间使用情况如何，直接回收。  
对于软引用和弱引用，在构造的时候可以指定一个引用队列，当对象被回收的时候，就会加入指定的引用队列，从而可以跟踪对象的回收情况。  
而且软引用和和弱引用适合保存可有可无的缓存数据，因为对它们进行 GC 不会导致内存溢出。  
虚引用是最弱的引用类型，几乎和没有引用是一样的，随时可能被回收，所以它的作用一般也是和引用队列一起用，跟踪垃圾回收过程。

## 常见垃圾回收算法
**引用计数器**  
对于一个对象 A，只要又任何一个对象引用了 A，则 A 的引用计数器加 1，引用失效时，引用计数器减 1。只要 A 的引用计数器的值为 0，则 A 不可能再被使用，也就是可以被回收了。  
这个方法有两个严重的问题：

- 循环引用问题：当两个对象循环引用时，彼此的引用计数器都不为 0，但没有第三个对象引用它们，换句话说，除了它俩互相引用，对外部已经是不可达了，这种情况这两个对象永远不会被回收。
- 每次引用产生和消除的时候都伴随一个加法和减法操作，对系统性能有一定的影响。

**标记清除算法（mark-sweep）**  
该算法将垃圾回收分为两个阶段：

- 标记阶段：从根节点开始，标记所有的可达对象，未被标记的对象就是垃圾对象。
- 清除阶段：清除所有未被标记的对象。

问题：产生大量的空间碎片。

**复制算法**  
核心思想：内存空间分为两块，每次只使用其中的一块，GC 的时候将正在使用的可达对象复制到另一块内存空间，这样可以保证没有碎片，然后把当前内存空间的所有对象都删除，最大的缺点是内存需要打对折。  
Java 的新生代串行垃圾回收器使用了复制算法的思想，新生代分为 eden、from 和 to 三个空间，其中 from 和 to 就是用于复制的、大小相等、地位相同的空间块，作用就是在 GC 的时候存放未被回收的对象。开始 GC 的时候，首先会对 eden 空间中的对象做标记，其中的存活对象会被复制到一个空的 survivor 中（假设是 to）。然后再看另一个 survivor 空间（假设是 from），这个空间 GC 不会做标记，而是对其中的对象的年龄加 1，然后复制到 to 中，这些进行完以后就清空 eden 和 from 中的对象。考虑上面的过程有没有意外，如果 eden 中要回收的对象在 to 中放不下怎么办？或者 to 的空间满了怎么办？或者 survivor 中对象的年龄太大了，这几种情况我们会把对象移到老年代中，以上整个过程叫做 minor gc，minor gc 的触发条件就是 eden 区满了。  
注意复制算法比较使用于新生代，这是因为新生代垃圾对象多于存活对象，复制算法效果比较好。

**标记压缩法**  
上面的复制算法适用于新生代，那么老年代垃圾回收如何处理呢？标记压缩算法就是老年代的回收算法。它在标记清除算法上做了一些优化，首先仍然是从根结点开始，对所有可达对象做一次标记，然后将所有存活对象压缩到内存的一端，最后清理掉边界之外的空间，这种方法既避免了碎片的产生，又不需要两块相同的内存空间，也叫做标记清除压缩（MarkSweepCompact）算法。

**分代算法**  
新生代使用复制算法，老年代使用标记压缩算法或者标记清除算法。  
而且为了支持高频率的新生代回收，虚拟机使用一种叫卡表的数据结构，卡表是一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。这样在新生代 GC 的时候，不用花大量时间扫描所有的老年代对象，先扫描卡表，当卡表标记为 1，再扫描对应区域的老年代对象，而卡表为 0 所在区域的老年代对象一定不含有新生代对象的引用。

**分区算法**  
将整个堆空间划分成多个小区间，每个小区间独立使用独立回收，每次合理回收若干个小区间，而不是整个堆空间，从而减少一次 GC 产生的停顿。

# 垃圾收集器和内存分配
## 串行回收器
特点：

- 使用单线程进行垃圾回收。
- 独占式的垃圾回收，会引起 STW。

新生代串行收集齐使用复制算法，老年代串行收集器使用的是标记压缩算法，可以使用以下参数做更多搭配：

- `-XX:+UseSerialGC`：新生代和老年代都使用串行回收器，当虚拟机在 client 模式下运行时，它是默认的垃圾收集器。
- `-XX:+UseParNewGC`：新生代使用 ParNew 回收器，老年代使用串行回收器。
- `-XX:+UseParallelGC`：新生代使用 Parallel 回收器，老年代使用串行回收器。

## 并行回收器
首先区分并发和并行的概念：并发是指收集器和应用线程交替执行，不会停顿应用程序；并行是指应用程序停止，同时由多个线程一起执行 GC，因此并行回收器不是并发的，此时应用程序完全刮起。

**新生代 ParNew 回收器**  
ParNew 是一个工作在新生代的回收器，只是简单的将串行回收器多线程化，也是独占式的，所以它只是强在并发能力上。开启 ParNew 回收器可以使用以下参数：

- `-XX:+UseParNewGC`：新生代使用 ParNew 回收器，老年代使用串行回收器。
- `-XX:+UseConcMarkSweepGC`：新生代使用 ParNew 回收器，老年代使用 CMS。

ParNew 回收器的工作线程数可以通过 `-XX:ParallelGCThreads` 来指定，一般最好与 CPU 数量相当，避免过多线程数，影响垃圾回收性能，注意所有的多线程并行垃圾收集器（不管是新生代还是老年代）都可以使用这个参数指定线程数。

**新生代 ParallelGC 回收器**  
新生代 ParrallelGC 表面上看来和 ParNew 回收器差不多，也是多线程的、独占式的回收器，但是它有一个重要的特点：非常关注系统的吞吐量。可以通过以下参数启用：

- `-XX:+UseParallelGC`：新生代使用 ParallelGC 回收器，老年代使用串行回收器。
- `-XX:+UseParallelOldGC`：新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。

ParallelGC 回收器提供了几个重要参数用来控制系统的性能和吞吐量。

- `-XX:+UseAdaptiveSizePolicy`：自适应的 GC 调节策略，可以自动调整新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄，从而可以在堆大小、吞吐量和停留时间之间有一个很好的平衡。
- `-XX:MaxGCPauseMills`：设置最大垃圾收集停顿时间，ParallelGC 在工作时，会自动调堆大小或者其他一些参数，尽可能使停留时间停顿在这个参数以内。但是也不能一味的设置的很小，否则为了达到预期的停留时间，虚拟机可能会使用一个较小的堆（小堆比大堆回收快），从而将导致垃圾回收变得很频繁，从而增加了垃圾回收总时间，降低了吞吐量。
- `-XX:GCTimeRatio`：设置吞吐量的大小，它的值是一个 0 到 100 的整数。假设 GCTimeRatio 的值是 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾回收。比如 GCTimeRatio 等于 19，则系统用于垃圾收集的时间不超过 1/(1+19)=5%。默认情况下，它的取值是 99，即不超过 1/(1+99)=1% 的时间用于垃圾收集。

注意，参数 `-XX:MaxGCPauseMills` 和 `-XX:GCTimeRatio` 是鱼和熊掌的关系，这两个参数是相互矛盾的，因为如果想要减少 GC 时间就势必会减少系统的吞吐量，所以我们只能在它们之间找到一个平衡。

**老年代 ParallelOldGC 回收器**  
老年代 ParallelOldGC 使用标记压缩算法，也是一种多线程、独占式的收集器，并且它也很关注系统的吞吐量。

## CMS 回收器
CMS 是 Concurrent Mark Sweep 的缩写，意为并发标记清除，它使用的是标记清除算法，同时使用多线程并行回收的收集器，它是一种作用在老年代和永久代上的垃圾收集器。与 ParallelGC 和 ParallelOldGC 不同，CMS 主要关注系统停顿时间。

**CMS 的工作步骤**  

- 初始标记（STW）：标记根对象。
- 并发标记：标记所有对象。
- 预清理：清理前准备以及控制停顿时间。
- 重新标记（STW）：修正并发标记数据。
- 并发清理：清理垃圾。
- 并发重置：重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。

**CMS 主要参数**  
启用 CMS 的参数是 `-XX:+UseConcMarkSweepGC`。

CMS 的默认并发线程数是 (ParallelGCThreads+3)/4，当然也可以通过 `-XX:ConcGCThreads` 或者 `-XX:ParallelCMSThreads` 手工设定。

CMS 回收器不是独占式回收器，CMS 收集数据期间应用程序也在同步运行，所以在清理垃圾的过程同时也在生成垃圾，因此不能等到对内存饱和时才进行垃圾回收，而是当对内存使用率达到某一阈值时便开始回收，以确保应用程序在 CMS 工作时，仍然有足够的内存支持应用程序运行。这个阈值可以通过 `-XX:CMSInitiatingOccupancyFraction` 来指定，默认是 68，即当老年代的空间使用率到达 68%，就进行一次 CMS 回收。如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，已经出现了内存不足的情况，此时 CMS 就会失败，虚拟机将启用老年代串行收集器进行垃圾收集，此时就发生了 STW。  
如果内存增长缓慢，可以把这个参数设置的大一点，有效减少 CMS 触发频率。如果内存增长很快，则应该降低这个值，以避免频繁触发老年代串行收集器。

CMS 使用的是标记清除算法，这个算法的缺点是会产生大量空间碎片，我们可以通过参数 `-XX:+UseCMSCompactAtFullCollection` 设置 CMS 在垃圾收集完成以后进行一次内存碎片整理，这个过程不是并发进行的。`-XX:CMSFullGCsBeforeCompaction` 参数可以用于设定多少次 CMS 回收后进行一次内存压缩。

*疑问：CMS 是否是 full gc？*
应该不是的，full gc 需要完全 STW，而 CMS 非独占式的。

**有关 Class 的回收**  
默认情况下，如果需要回收永久代 Perm 区，那么需要触发一次 Full GC。

如果需要使用 CMS 回收 Perm 区，则需要打开 `-XX:+CMSClassUnloadingEnabled`。

## G1 回收器
G1 回收器（Garbage-First）是在 JDK 1.7 中正式使用的全新的垃圾收集器，用来取代 CMS 回收器。G1 回收器拥有独特的垃圾回收策略，这和之前的回收器截然不同。从分代上来看，G1 依然属于分代垃圾回收器，会区分新生代和老年代，依然有 eden 和 survivor 区，但从堆的结构来看，它并不要求整个 eden 区、年轻代或者老年代都连续。G1 使用了全新的分区算法，特点如下：

- 并行性：可以由多个 GC 线程同时工作，有效利用多核计算能力。
- 并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收期间完全阻塞应用程序。
- 分代 GC：对比其他回收器，或者工作在新生代，或者工作在老年代，G1 会兼顾新生代和老年代。
- 空间整理：G1 在回收过程中就会进行适当的对象移动，减少空间碎片，而不像 CMS，若干次 GC 后，CMS 必须进行一次碎片整理。
- 可预见性：由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿也能得到较好的控制。

G1 的收集过程有 4 个阶段：

**新生代 GC**  
新生代 GC 的主要工作和其他收集器差不多，会STW，在 eden 区占慢的时候启动新生代 GC，只处理 eden 和 survivor 区，回收后，所有的 eden 区被清空，而 survivor 会被回收一部分数据，但至少还会存在一个 survivor 区，老年代的区域增加，因为部分 survivor 或者 eden 区的对象可能会晋升到老年代。

**并发标记周期**  
G1 的并发阶段和 CMS 有点相似，目的都是为了降低一次停顿时间，而将可以和应用程序并发的部分单独提取出来执行，并发标记周期可以分成以下几步：

- 初始标记（STW）：标记从根对象直接可达的对象，这个阶段会伴随一次新生代 GC，它是会产生全局停顿的，应用程序在这个阶段必须停止执行。
- 根区域扫描：这个阶段 eden 区域被清空，所以会扫描由 survivor 区直接可达的老年代区域，并标记这些可达的对象，这个阶段可以和应用程序并发执行，但是不能和新生代 GC 并发执行（因为新生代 GC 会修改 survivor 区域），所以如果恰好此时需要新生代 GC，那么新生代 GC 就要延后执行。
- 并发标记：和 CMS 类似，将会扫描并查找整个堆的存活对象，并做好标记。这是一个并发的过程，可以被新生代 GC 打断。
- 重新标记（STW）：由于并发标记时应用程序仍然在同步执行，所以标记结果可能需要做修正，因此重新标记的过程是需要 STW 的。在 G1 中，这个过程使用 SATB（Snapshot-At—The-Beginning）算法完成，即 G1 会在标记之处为存活对象创建一个快照，这个快照有助于加速重新标记的速度。
- 独占清理（STW）：这个阶段会引起停顿，将计算各个区域存活对象和 GC 回收的比例并且进行排序，从而确定哪些区域可以被混合回收，这些区域会被标记为 G，会在后续的混合回收阶段进行收集，这些将要被回收的区域会被 G1 记录在一个称为 Collection Sets（回收集）的集合中。同时，在这个阶段还会更新记忆集（Remember Sets），记忆集是 G1 维护的一个数据结构，简称 RS，其更底层的数据结构是卡表，用来记录本区域中被其他区域引用的对象，用来在标记阶段快速确定哪些对象是存活的。由于在系统在运行过程中对象之间的引用关系可能随时改变，所以为了更高效跟踪这些引用关系，会把这些变化记录在 Update Buffers 中，然后根据 Update Buffers 更新 RS。
- 并发清理阶段：会识别并清理完全空闲的区域。

*疑问：为什么独占清理阶段需要 STW？*

**混合回收**  
在并发标记周期中，总体上垃圾回收的比例很低，但是已经标记了哪些区域含有较多的垃圾对象，在混合回收阶段，就可以优先回收这些区域，这也是 G1 这个名字的由来，即 Garbage First Garbage Collector，直译为垃圾优先的垃圾收集器。  
这个阶段称为混合回收，是因为既会执行正常的新生代 GC，又会选取一些被标记的老年代区域进行回收。混合 GC 会执行多次，直到回收了足够多的内存空间。然后它会触发一次新生代 GC，新生代 GC 后可能又会发生一次并发标记周期的处理，最后又回引起混合 GC 的执行。因此整个 GC 过程如图：

![](/resource/mixed-gc.png)

**必要时的 Full GC**  
并发执行时内存不足，或者老年代无法容纳幸存对象，就会触发一次 Full GC。

**G1 相关的参数**  

- `-XX:+UseG1GC`：打开 G1 收集器。  
- `-XX:MaxGCPauseMills`：最大停顿时间，最重要的一个参数。
- `-XX:ParallelGCThreads`：GC 的工作线程数。
- `-XX:InitiatingHeapOccupancyPercent`：当这个堆使用率达到多少时触发并发标记周期的执行，这个值一旦被设定，G1 就不会做修改，即不会为了减少停顿时间而更改这个值。

## 关于垃圾回收的一些其他细节
**禁用 System.gc()**  
默认情况 System.gc() 会直接触发 Full GC，同时对老年代和新生代进行回收，垃圾回收最好自动进行，所以可以通过参数 `-XX:+DisableExplicitGC` 禁用掉明确触发 Full GC 的行为。

**System.gc() 使用并发回收**  
如果不想禁用 System.gc() 的话，那我们需要对其做一些优化。默认情况下，System.gc() 生效，会触发传统的 Full GC。那么如果我们想要用 CMS 或者 G1 进行 GC 应该怎么设置呢？首先肯定需要在参数中设置 UseG1GC 和 UseConcMarkSweepGC，另外记住还必须打开参数 `-XX:+ExplicitGCInvokesConcurrent`。

**并行 GC 前额外触发的新生代 GC**  
在使用并行回收器时，在 Full GC 之前首先进行一次新生代 GC，这样做的目的是先将新生代进行一次收集，避免将所有回收工作交给一次 Full GC 进行，从而尽可能的缩短一次停顿的时间。

**对象何时进入老年代**  
一般来说，当对象的年龄达到一定大小，一定会离开新生代进入老年代，这个参数可以通过 `-XX:MaxTenuringThreshold` 来设置，但是注意这个值是一个对象进入老年代的最大上线，即充分非必要条件，在某些特殊情况下即使年龄没有达到这个值也可以进入老年代。  
影响对象何时晋升到老年代的另一个重要参数就是 `-XX:TargetSurvivorRatio`，它用于设置 survivor 区的目标使用率，默认为 50，即如果 survivor 区在 GC 后超过 50% 的使用率，那么相应的晋升年龄可能会更小，小于上面 `-XX:MaxTenuringThreshold` 的大小。  
除了年龄外，对象的大小也会影响对象的晋升，可以通过参数 `-XX:PretenureSizeThreshold` 设置一个对象直接晋升到老年代的大小阈值，单位是字节。只要对象大于该值，就会绕过新生代，直接在老年代分配。这个参数只对串行回收器和 ParNew 有效，对于 ParallelGC 无效。默认情况下该值为 0，也就是不指定最大的晋升大小，一切由运行情况决定。

**在 TLAB 上分配对象**  
TLAB 全称是 Thread Local Allocation Buffer，即线程本地分配缓存。从名字可以看出来，TLAB 是一个线程专用的内存分配区域。使用这样一个区域是为了避免多线程冲突，提高线程分配效率。TLAB 本身占用了 eden 区的空间，在 TLAB 启用的情况下，虚拟机会为每一个 Java 线程分配一块 TLAB 空间。

TLAB 可以通过参数 `-XX:+UseTLAB`，当然 TLAB 本身就是默认开启的，并且虚拟机会在运行时自动调节分配给 TLAB 空间的大小。如果想要禁用自动调整 TLAB 的大小，可以使用 `-XX:-ResizeTLAB` 禁用 ResizeTLAB，并使用 `-XX:TLABSize` 手工指定一个 TLAB 的大小。

如果想管擦 TLAB 的使用情况，可以打开跟踪参数 `-XX:+PrintTLAB`。

**对象分配流程**  

![](/resource/allocate-obj.png)

**方法 finalize() 对垃圾回收的影响**  
该函数允许在子类中被重载，一般用于对象被回收时进行资源的释放，一般尽量不要使用 finalize() 进行资源释放，原因如下：

- finalize() 可能会导致对象复活。
- finalize() 的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize() 将没有机会执行。
- 一个糟糕的 finalize() 会严重影响 GC 的性能。

## 与垃圾收集器相关的的常用 GC 参数
![](/resource/gc-options.jpg)
