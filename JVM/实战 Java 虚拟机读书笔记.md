# 初探 Java 虚拟机
虚拟机是一款软件，用来执行一系列虚拟计算机指令。  
虚拟机分为系统虚拟机和程序虚拟机，系统虚拟机是对物理计算机的仿真，提供了可运行完整操作系统的软件平台，如 VMware；程序虚拟机专门为执行单个计算就程序而设计，最著名的就是 Java 虚拟机。

# 认识 Java 虚拟机的基本结构  
Java 虚拟机的基本结构如图：

![](/resource/jvm-arc.png)

- 类加载子系统：从文件系统或者网络中加载 Class 信息，加载的**类信息**存放在一块称为方法区的**内存空间**。除了类信息，方法区还可能存放**运行时常量池**信息。  
- Java 堆：在虚拟机**启动**的时候建立，是 Java 程序**最主要的内存**工作区域。几乎所有的 **Java 对象实例**都存放在这里，堆空间是**所有线程共享的**。
- 直接内存：是 **Java 堆外**的、**直接向系统申请**的内存空间，Java 的 **NIO 库**允许 Java 程序使用直接内存。**速度优于 Java 堆**，因此读写频繁的场景可以考虑使用直接内存。而且大小**不会受限于 Xmx 指定的最大堆大小**。  
- 垃圾回收系统：可以对** 方法区、Java 堆和直接内存**进行回收，当然，**Java 堆**是其回收的重点对象。  
- Java 栈：每一个 Java 虚拟机**线程**都有一个**私有**的 Java 栈，在**线程创建**的时候被创建。Java 栈中保存着**帧信息**，Java 栈中保存着**局部变量、方法参数**，和 Java 方法的调用和返回密切相关。  
- 本地方法栈：和 Java 栈很类似，最大的不同是 Java 栈用于 **Java 方法**的调用，而本地方法栈用于**本地方法**的调用，本地方法一般是 C 语言编写。  
- PC（Program Counter）寄存器：也是线程私有空间，任意时刻一个 Java 线程总是在执行一个方法，这个正在被执行的方法称为**当前方法**。如果当前方法不是本地方法，PC 就会指向**当前正在被执行的指令**，如果当前方法是本地方法，PC 的值就是 undefined。  
- 执行引擎：执行虚拟机中的**字节码**。

## Java 栈
每一次**函数调用**，都会有一个对应的**栈帧**被压入 Java 栈，每一个函数调用结束，都会有一个栈帧被弹出 Java 栈。Java 方法有两种返回函数的方式，一种是正常的通过 return 指令返回，另一种是抛出异常，不论哪种方式，都会导致栈帧被弹出。

Java 栈空间的大小可以通过设置 `-Xss` 来指定，每一次入栈的栈帧都会占用一定的栈空间，如果函数调用太多，当请求的栈深度大于最大栈深度是，系统就会抛出 StackOverflowError 栈溢出错误。

再来讲一下栈帧中的内容，一般必须包含局部变量表、操作数栈和帧数据区这几个部分。

**局部变量表**  
局部变量表用来保存**函数的参数和局部变量**，因此函数的参数和局部变量越多，局部变量表越大，占用的栈空间就越多。  
我们可以使用 `jclasslib` 工具更进一步查看函数的局部变量信息，可以通过 `Maximum local variables` 查看局部变量表占了几个字，字（word）指的是计算机内存中占据一个单独的内存单元编号的一组二进制串，一般 32 位计算机上一个字为 4 个字节长度，即 32 bit，所以一个 int 类型是一个字，一个 long 类型是两个字。  

*疑问：Class 文件的局部变量表和 Java 栈中的局部变量表这两个概念有什么区别？*  
Class 文件中的局部变量表是 Class 文件的一个属性，可以显示栈帧中局部变量表的每个局部变量的作用域范围、所在槽位的索引（index 列）、变量名（name 列）和数据类型。  
栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量**过了其作用域**，之后声明的新的局部变量（变量名不一定要相同）**很有可能**会复用过期局部变量的槽位，从而节省资源。

局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中**直接或间接引用**的对象都是不会被回收的。我们可以使用参数 `-XX:+PrintGC` 来查看垃圾回收的过程。

**操作数栈**  
操作数栈用来保存**计算的中间结果**，同时作为计算过程中变量临时的存储空间，比如 `iadd` 指令，它会在操作数栈中弹出两个整数并进行加法计算，计算结果会被入栈。  
这样说来它和局部变量表有什么区别呢，局部变量表存储局部变量，程序会使用这些局部变量并做一些计算，操作数栈就给这个**计算过程**中的变量提供一个暂存位置。

**帧数据区**  
帧数据区保存的数据与**常量池解析**、**正常方法返回**和**异常处理**有关。  
大部分的 Java 字节码指令需要进行常量池访问，在帧数据区中保存这访问常量池的指针，方便程序访问常量池。  
当函数返回或者出现异常时，栈帧内会有一个异常处理表告诉程序下一步应当如何进行。

**栈上分配**  
对于线程私有的对象（或者说是不可能被其他线程访问的对象），可以将它们打散分配在栈上，而不是分配在堆上，这样可以在函数调用结束后自动销毁，而不需要垃圾回收器的介入。  
那么哪些情况可以使用栈上分配呢？这就需要进行**逃逸分析**，目的是判断对象的作用域是否有可能逃逸出函数体。  
如下代码显示了一个逃逸对象：

```java
private static User u;
public static void alloc() {
    u = new User();
    u.id = 5;
    u.name = "geym";
}
```

对象 User u 是类的成员变量，可能被任何线程访问，因此属于逃逸对象，下面代码显示一个非逃逸对象：

```java
public static void alloc() {
    User u = new User();
    u.id = 5;
    u.name = "geym";
}
```

这里对象 User u 是以局部变量的形式存在的，并且没有被函数 alloc 返回，因此并未逃逸，对于这种情况，虚拟机就可以将 User 分配在栈上，而不是堆上。

栈上分配需要开启两个参数，参数 `-XX:+DoEscapeAnalysis` 启用逃逸分析，参数 `-XX:+EliminateAllocations` 开启了标量替换（默认打开），允许将对象打散到栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段会被视为两个独立的局部变量进行分配。

栈上分配适合于**大量的零散小对象**的优化机制，但由于和堆空间相比，栈空间较小，因此大对象不适合在栈上分配。

## 方法区
方法区也是被所以线程共享的，保存系统的类信息，例如类的**字段、方法、常量池**等，方法区的大小决定了系统可以保存多少个类。  
JDK 1.6 和 JDK 1.7 中，方法区可以理解成永久区（Perm），可以使用参数 `-XX:PermSize` 和 `-XX:MaxPermSize` 指定初始永久区大小和最大永久区大小。如果系统使用了一些**动态代理**，那么有可能会在**运行时**生成大量的类，可能会导致永久区溢出。  
JDK 1.8 中，永久区已经被永久移除了，取而代之的是**元数据区**。元数据区的大小可以使用参数 `-XX:MaxMetaspaceSize` 指定，这是一块堆外的直接内存。与永久区不同的是，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常，异常信息为 `java.lang.OutOfMemoryError: Metaspace`。

# 常用 Java 虚拟机参数
## 跟踪垃圾回收
`-XX:+PrintGC`：打印最简略的 GC 日志。  

`-XX:+PrintGCDetails`：更加详细的 GC 信息。Full GC 会同时回收新生代、老年代和永久区。user 表示用户态 CPU 耗时，sys 表示系统 CPU 耗时，real 表示 GC 实际的时间。  
*疑问：用户态和系统有什么区别？*  
*疑问：下界、上界和当前上界有什么区别？*  

`-XX:+PrintHeapAtGC`：在每次 GC 前后分别打印堆的信息。

`-XX:+PrintGCTimeStamps`：输出 GC 发生的时间，输出时间为虚拟机启动后的时间偏移量。

`-XX:+PrintGCApplicationConcurrentTime`：打印应用程序的执行时间。

`-XX:+PrintGCApplicationStoppedTime`：打印应用程序由于 GC 而产生的停顿时间。

`-XX:+PrintReferenceGC`：跟踪系统内软引用、弱引用、虚引用和 Finalize 队列。

`-Xloggc:log/gc.log`：GC 日志记录在当前目录下 log 文件夹下的 gc.log 文件中。

## 跟踪类加载/卸载
可以使用 `-verbose:class` 跟踪类的加载和卸载，也可以单独使用 `-XX:+TraceClassLoading` 跟踪类的加载，使用 `-XX:+TraceClassUnloading` 跟踪类的卸载，这两者等价。

## 虚拟机系统参数的查看
`-XX:+PrintVMOptions`：打印虚拟机显式接收到的参数。  

`-XX:+PrintCommandLineFlags`：打印传递给虚拟机的显式和隐式参数，隐式参数可能是虚拟机启动时自行设置的。  

`-XX:+PrintFlagsFinal`：打印所有系统参数的值。

## 堆的配置参数
首先最常见的，用 `-Xms` 和 `-Xmx` 配置初始堆大小和最大堆大小，一个基本的理解是最大可用内存是 -Xmx 的取值，当前总内存不小于 -Xms 的值，因为总内存总是在 -Xms 和 -Xmx 之间，从 -Xms 开始根据需要上涨。实际上的内存比上面的值略小一点。  
在实际工作中可以直接将 -Xms 和 -Xmx 设置相等，这样可以减少程序运行时的垃圾回收次数。

`-Xmn`：新生代大小，一般设置为整个堆空间的 1/3 到 1/4 左右。

`-XX:SurvivorRatio`：新生代中 eden 空间和 from/to 空间的比例关系，默认值是 8，即如果 from 和 to 的空间各占 1 份，那么 eden 就占 8 份，整个新生代就占 10 份。

`-XX:NewRatio`：老年代和新生代的比例。

当堆溢出，即发生 OOM 的时候，我们应该配置哪些参数来排查问题进行处理呢？  
首先我们需要详细的现场信息来排查问题，可以使用 `-XX:+HeapDumpOnOutOfMemoryError` 导出整个堆的信息，使用 `-XX:HeapDumpPath=/path/error.dump` 来指定导出这个堆到哪个文件路径下面，然后我们可以使用 MAT 等工具打开该文件进行分析。  
同时我们还可以在 OOM 时跑一个脚本，用于奔溃程序自救、报警或存一些有用信息，使用方法是 `-XX:OnOutOfMemoryError=/path/alarm.sh`。

## 直接内存配置
最大可用直接内存可以使用参数 `-XX:MaxDirectMemorySize` 设置，如不设置，默认值为最大堆内存 -Xmx。当直接内存使用量达到 -XX:MaxDirectMemorySize 时，就会出发垃圾回收，如果垃圾回收不能有效释放足够空间，也会引起 OOM。  
*疑问：直接内存中如果进行垃圾回收？**

直接内存适合申请空间次数较少、读写较频繁的场合。如果内存空间本身需要频繁申请，则并不适合使用直接内存。

## 虚拟机的 client 和 server 模式
目前 Java 虚拟机支持 client 和 server 两种运行模式，分别使用 `-client` 和 `-server` 来指定。  
与 client 模式相比，server 模式的启动比较慢，因为 server 模式会尝试收集更多的系统性能信息，使用更复杂的优化算法对程序进行优化。因此，当系统完全启动并进入运行稳定期后，server 模式的执行速度会远远快于 client 模式，所以对于长期后台运行的系统，一般选择 server 模式，对于用户界面程序，运行时间不长又追求启动速度，一般选择 client 模式。

从发展趋势来看，未来 64 位系统必然会取代 32 位系统，而在 64 位系统中虚拟机更倾向于使用 server 模式运行。

# 垃圾回收概念和算法
垃圾回收，简称 GC，需要分两步进行，第一要知道什么是垃圾，第二才可以回收这些垃圾。首先看如何判断一个对象是否能够被回收。
## 如何判断哪些是垃圾？
垃圾回收的基本判断思想是看一个对象是否可达，可达的概念是从根对象进行引用搜索，最终是否可以到达这个对象，如果可以到达，我们就说这是可达对象，说明这个对象正在被使用，不是垃圾；如果最终不能到达这个对象，即这个对象没有被引用到，那么就说这是个不可达对象，一般来说，此对象需要被回收。但事实上，一个不可达对象可能在某一条件下复活自己，如果是这样，那么对它的回收就是不合理的，那么到底怎样的对象才真正算一个垃圾呢，我们首先看一下站在垃圾回收的角度上对象的 3 种状态：

- 可触及的：从根对象开始，可以到达这个对象，即是一个可达对象。
- 可复活的：对象的所有引用都被释放，此时是不可达对象，但是该不可达对象有可能在 finalize() 函数中复活。
- 不可触及的：对象的 finalize() 函数被调用，但是没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为 finalize() 函数只会被调用一次。

以上三种状态，只有对象不可触及时才算真正的垃圾，才可以被回收。

*疑问：什么叫做根对象？从根对象引用搜索是什么意思？是指查看是否有指向搜索对象的引用吗？*  
*疑问：finalize() 函数是什么时候调用的？GC 的时候一定会调用吗？还是说调用时间不明确？*

当释放一个对象的引用时，这个对象就变成不可达了，如果此时进行第一次 GC，如果调用 finalize() 函数的时候，对象被复活（如通过 this 引用的方式），并且引用外泄（可以被外部访问），那么该对象就复活了，相反如果调用 finalize() 函数以后没有复活，由于 finalize() 只会被调用一次，那么第二次 GC 的时候，对象就会被直接回收。

**引用的强度和可触及性分析**  
Java 提供 4 个级别的引用：强引用、软引用、弱引用和虚引用。  
强引用是可触及的，不会被回收的。  
软引用是比强引用弱一点的引用类型，当堆空间不足时，软引用对象就会被回收，所以软引用不会引起内存溢出。  
弱引用又比软引用弱，只要系统 GC，发现了弱引用，不管堆空间使用情况如何，直接回收。  
对于软引用和弱引用，在构造的时候可以指定一个引用队列，当对象被回收的时候，就会加入指定的引用队列，从而可以跟踪对象的回收情况。  
而且软引用和和弱引用适合保存可有可无的缓存数据，因为对它们进行 GC 不会导致内存溢出。  
虚引用是最弱的引用类型，几乎和没有引用是一样的，随时可能被回收，所以它的作用一般也是和引用队列一起用，跟踪垃圾回收过程。

## 常见垃圾回收算法
**引用计数器**  
对于一个对象 A，只要又任何一个对象引用了 A，则 A 的引用计数器加 1，引用失效时，引用计数器减 1。只要 A 的引用计数器的值为 0，则 A 不可能再被使用，也就是可以被回收了。  
这个方法有两个严重的问题：

- 循环引用问题：当两个对象循环引用时，彼此的引用计数器都不为 0，但没有第三个对象引用它们，换句话说，除了它俩互相引用，对外部已经是不可达了，这种情况这两个对象永远不会被回收。
- 每次引用产生和消除的时候都伴随一个加法和减法操作，对系统性能有一定的影响。

**标记清除算法（mark-sweep）**  
该算法将垃圾回收分为两个阶段：

- 标记阶段：从根节点开始，标记所有的可达对象，未被标记的对象就是垃圾对象。
- 清除阶段：清除所有未被标记的对象。

问题：产生大量的空间碎片。

**复制算法**  
核心思想：内存空间分为两块，每次只使用其中的一块，GC 的时候将正在使用的可达对象复制到另一块内存空间，这样可以保证没有碎片，然后把当前内存空间的所有对象都删除，最大的缺点是内存需要打对折。  
Java 的新生代串行垃圾回收器使用了复制算法的思想，新生代分为 eden、from 和 to 三个空间，其中 from 和 to 就是用于复制的、大小相等、地位相同的空间块，作用就是在 GC 的时候存放未被回收的对象。开始 GC 的时候，首先会对 eden 空间中的对象做标记，其中的存活对象会被复制到一个空的 survivor 中（假设是 to）。然后再看另一个 survivor 空间（假设是 from），这个空间 GC 不会做标记，而是对其中的对象的年龄加 1，然后复制到 to 中，这些进行完以后就清空 eden 和 from 中的对象。考虑上面的过程有没有意外，如果 eden 中要回收的对象在 to 中放不下怎么办？或者 to 的空间满了怎么办？或者 survivor 中对象的年龄太大了，这几种情况我们会把对象移到老年代中，以上整个过程叫做 minor gc，minor gc 的触发条件就是 eden 区满了。  
注意复制算法比较使用于新生代，这是因为新生代垃圾对象多于存活对象，复制算法效果比较好。

**标记压缩法**  
上面的复制算法适用于新生代，那么老年代垃圾回收如何处理呢？标记压缩算法就是老年代的回收算法。它在标记清除算法上做了一些优化，首先仍然是从根结点开始，对所有可达对象做一次标记，然后将所有存活对象压缩到内存的一端，最后清理掉边界之外的空间，这种方法既避免了碎片的产生，又不需要两块相同的内存空间，也叫做标记清除压缩（MarkSweepCompact）算法。

**分代算法**  
新生代使用复制算法，老年代使用标记压缩算法或者标记清除算法。  
而且为了支持高频率的新生代回收，虚拟机使用一种叫卡表的数据结构，卡表是一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。这样在新生代 GC 的时候，不用花大量时间扫描所有的老年代对象，先扫描卡表，当卡表标记为 1，再扫描对应区域的老年代对象，而卡表为 0 所在区域的老年代对象一定不含有新生代对象的引用。

**分区算法**  
将整个堆空间划分成多个小区间，每个小区间独立使用独立回收，每次合理回收若干个小区间，而不是整个堆空间，从而减少一次 GC 产生的停顿。
